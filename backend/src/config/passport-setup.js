const passport = require("passport");
const GitHubStrategy = require("passport-github").Strategy;
const MsftOIDCStrategy = require("passport-azure-ad").OIDCStrategy;
const UserCtrl = require("../controllers/UserCtrl");
const GitHubApiCtrl = require("../controllers/GitHubApiCtrl");
const UserModel = require("../models/User").default;
const TokenModel = require("../models/Token").default;
const { logger, errorHandler } = require("../logs/logger");

import { syncWithGitHub, updateTraffic } from '../config/updateRepositories';

passport.serializeUser((user, done) => {
  done(null, user.id);
});

passport.deserializeUser(async (id, done) => {
  let user;
  try {
    user = await UserModel.findById(id);
  } catch (err) {
    errorHandler(
      `${arguments.callee.name}: Error caught when deserializing user with id ${id}.`,
      err
    );
  }
  done(null, user);
});

passport.use(
  new MsftOIDCStrategy(
    {
      identityMetadata: process.env.MSFT_IDENTITY_META,
      clientID: process.env.MSFT_CLIENT_ID,
      clientSecret: process.env.MSFT_CLIENT_SECRET,
      responseType: "id_token",
      responseMode: "form_post",
      redirectUrl: process.env.MSFT_REDIRECT_URL,
      allowHttpForRedirectUrl: true,
      validateIssuer: false,
      issuer: null,
      passReqToCallback: false,
      useCookieInsteadOfSession: true,
      // Required if `useCookieInsteadOfSession` is set to true. You can provide multiple set of key/iv pairs for key
      // rollover purpose. We always use the first set of key/iv pair to encrypt cookie, but we will try every set of
      // key/iv pair to decrypt cookie. Key can be any string of length 32, and iv can be any string of length 12.
      cookieEncryptionKeys: [
        {
          key: process.env.MSFT_COOKIE_ENC_KEY_1,
          iv: process.env.MSFT_COOKIE_ENC_IV_1,
        },
        {
          key: process.env.MSFT_COOKIE_ENC_KEY_2,
          iv: process.env.MSFT_COOKIE_ENC_IV_2,
        },
      ],
      scope: ["profile"],
    },
    async (iss, sub, profile, accessToken, refreshToken, done) => {
      console.log("profile: ", profile);
      if (!profile.oid) {
        return done(new Error("No oid found"), null);
      }
      console.log("JSON.stringify(profile): ", JSON.stringify(profile));
      const user = await UserModel.findOne({ msft_oid: profile.oid });
      if (!user) {
        const u = await new UserModel({
          msft_oid: profile.oid,
          username: profile._json.preferred_username,
        }).save();
        return done(null, u);
      }

      return done(null, user);
    }
  )
);

passport.use(
  /* The GitHubStrategy allows GitHub users to track ther repositories for which
  they have push access */
  new GitHubStrategy(
    {
      clientID: process.env.GH_CLIENT_ID,
      clientSecret: process.env.GH_CLIENT_SECRET,
    },
    async (accessToken, refreshToken, profile, done) => {
      /* At the moment when this application was developed, the GitHub token generated for
      one user does not expire. But, only the last 10 tokens generated token will be
      valid. This is why, we will always store the last generated token. Also, the token
      generated by the GitHub OAuth2 API is a sensible information, so we will not store
      it in clear in the database (more information can be found in the Token.js file). */
      let currentUser;
      try {
        currentUser = await UserModel.findOne({ githubId: profile.id });
      } catch (err) {
        errorHandler(
          `${arguments.callee.name}: Error caught while getting from database the user with githubId ${profile.id}.`,
          err
        );
      }

      if (currentUser) {
        /* The GitHub user was found in the database, so we will update its latest token */
        logger.info(
          `${arguments.callee.name}: Updating token for user ${currentUser.username}...`
        );
        let t;
        try {
          await TokenModel.deleteOne({
            _id: currentUser.token_ref,
          }); /* Delete old token */
          t = await new TokenModel({
            value: accessToken,
          }).save(); /* Create new token */
          currentUser.token_ref = t._id; /* Update user */
          currentUser = await currentUser.save();
          await UserCtrl.updateProfile(currentUser);
        } catch (err) {
          errorHandler(
            `${arguments.callee.name}: Error caught while updating token for user ${currentUser.username}.`,
            err
          );
        }

        done(null, currentUser);
      } else {
        /* The GitHub user was not found in the database, so we will create it */
        logger.info(`${arguments.callee.name}: Creating new user...`);

        /* Create new token */
        let t;
        try {
          t = await new TokenModel({ value: accessToken }).save();
        } catch (err) {
          errorHandler(
            `${arguments.callee.name}: Error caught while saving token for the new user ${profile.username}.`,
            err
          );
        }

        let userEmails;
        try {
          userEmails = await GitHubApiCtrl.getUserEmails(accessToken);
        } catch (err) {
          errorHandler(
            `${arguments.callee.name}: Error caught while getting user emails for user ${profile.username}.`,
            err
          );
        }

        let emails = [];

        if (userEmails && userEmails.success) {
          emails = userEmails.data.filter(
            (emails) => emails.visibility !== null
          );
        }

        let newUser;
        try {
          newUser = await new UserModel({
            username: profile.username,
            githubId: profile.id,
            githubEmails: emails,
            token_ref: t._id,
          }).save();
        } catch (err) {
          errorHandler(
            `${arguments.callee.name}: Error caught while saving new user ${profile.username}.`,
            err
          );
        }

        /* Start tracking the user's repositories from the GitHub account. */
        try {
          newUser.token_ref = t;
          await syncWithGitHub(newUser);
          await updateTraffic(newUser);
        } catch (err) {
          errorHandler(
            `${arguments.callee.name}: Error caught while getting new repos for the new created user ${profile.username}.`,
            err
          );
        }

        done(null, newUser);
      }
    }
  )
);
